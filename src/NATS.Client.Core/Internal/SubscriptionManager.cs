using System.Buffers;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Logging;
using NATS.Client.Core.Commands;

namespace NATS.Client.Core.Internal;

internal record struct SidMetadata(NatsSubscriptionProps Properties, WeakReference<NatsSubBase> WeakReference);

internal sealed record SubscriptionMetadata(int Sid);

internal sealed class SubscriptionManager : INatsSubscriptionManager, IAsyncDisposable
{
    private readonly ILogger<SubscriptionManager> _logger;
    private readonly bool _trace;
    private readonly bool _debug;
    private readonly object _gate = new();
    private readonly NatsConnection _connection;
    private readonly string _inboxPrefix;
    private readonly ConcurrentDictionary<int, SidMetadata> _bySid = new();
    private readonly ConditionalWeakTable<NatsSubBase, SubscriptionMetadata> _bySub = new();
    private readonly CancellationTokenSource _cts;
    private readonly Task _timer;
    private readonly TimeSpan _cleanupInterval;
    private readonly InboxSub _inboxSubSentinel;
    private readonly SemaphoreSlim _inboxSubLock = new(initialCount: 1, maxCount: 1);

    private int _sid; // unique alphanumeric subscription ID, generated by the client(per connection).
    private InboxSub _inboxSub;
    private int _inboxSid;

    public SubscriptionManager(NatsConnection connection, string inboxPrefix)
    {
        _connection = connection;
        _inboxPrefix = inboxPrefix;
        _logger = _connection.Opts.LoggerFactory.CreateLogger<SubscriptionManager>();
        _debug = _logger.IsEnabled(LogLevel.Debug);
        _trace = _logger.IsEnabled(LogLevel.Trace);
        _cts = new CancellationTokenSource();
        _cleanupInterval = _connection.Opts.SubscriptionCleanUpInterval;
        _timer = Task.Run(CleanupAsync);
        InboxSubBuilder = new InboxSubBuilder(connection.Opts.LoggerFactory.CreateLogger<InboxSubBuilder>());
        _inboxSubSentinel = new InboxSub(InboxSubBuilder, new NatsSubscriptionProps(nameof(_inboxSubSentinel), _connection.InboxPrefix), default, connection, this);
        _inboxSub = _inboxSubSentinel;
    }

    internal InboxSubBuilder InboxSubBuilder { get; }

    internal int InboxSid => Interlocked.CompareExchange(ref _inboxSid, 0, 0);

    public ValueTask SubscribeAsync(NatsSubBase sub, CancellationToken cancellationToken)
    {
        var props = new NatsSubscriptionProps(sub.Subject, _connection.InboxPrefix, sub.QueueGroup);
        if (Telemetry.HasListeners())
        {
            using var activity = Telemetry.StartSendActivity($"{_connection.SpanDestinationName(sub.Subject)} {Telemetry.Constants.SubscribeActivityName}", _connection, sub.Subject, null, null);
            try
            {
                if (props.IsInboxSubject(_connection.InboxPrefix))
                {
                    if (sub.QueueGroup != null)
                    {
                        throw new NatsException("Inbox subscriptions don't support queue groups");
                    }

                    return SubscribeInboxAsync(sub, cancellationToken);
                }

                return SubscribeInternalAsync(props, sub, cancellationToken);
            }
            catch (Exception ex)
            {
                Telemetry.SetException(activity, ex);
                throw;
            }
        }

        if (props.IsInboxSubject(_connection.InboxPrefix))
        {
            if (sub.QueueGroup != null)
            {
                throw new NatsException("Inbox subscriptions don't support queue groups");
            }

            return SubscribeInboxAsync(sub, cancellationToken);
        }

        return SubscribeInternalAsync(props, sub, cancellationToken);
    }

    public ValueTask PublishToClientHandlersAsync(NatsProcessProps props, in ReadOnlySequence<byte>? headersBuffer, in ReadOnlySequence<byte> payloadBuffer)
    {
        if (_trace)
        {
            _logger.LogTrace(NatsLogEvents.Subscription, "Received subscription data for {Subject}/{Sid}", props.Subject, props.SubscriptionId);
        }

        int? orphanSid = null;
        lock (_gate)
        {
            if (_bySid.TryGetValue(props.SubscriptionId, out var sidMetadata))
            {
                if (sidMetadata.WeakReference.TryGetTarget(out var sub))
                {
                    if (_trace)
                    {
                        _logger.LogTrace(NatsLogEvents.Subscription, "Found subscription handler for {Subject}/{Sid}", props.Subject, props.SubscriptionId);
                    }

                    return sub.ReceiveAsync(props, headersBuffer, payloadBuffer);
                }
                else
                {
                    _logger.LogWarning(NatsLogEvents.Subscription, "Subscription GCd but was never disposed {Subject}/{Sid}", props.Subject, props.SubscriptionId);
                    orphanSid = props.SubscriptionId;
                }
            }
            else
            {
                _logger.LogWarning(NatsLogEvents.Subscription, "Can\'t find subscription for {Subject}/{Sid}", props.Subject, props.SubscriptionId);
            }
        }

        if (orphanSid != null)
        {
            try
            {
                return _connection.UnsubscribeAsync(new NatsSubscriptionProps(props.SubscriptionId));
            }
            catch (Exception e)
            {
                _logger.LogWarning(NatsLogEvents.Subscription, "Error unsubscribing orphan SID during publish: {Message}", e.GetBaseException().Message);
            }
        }

        return default;
    }

    public async ValueTask DisposeAsync()
    {
#if NET8_0_OR_GREATER
        await _cts.CancelAsync().ConfigureAwait(false);
#else
        _cts.Cancel();
#endif

        WeakReference<NatsSubBase>[] subRefs;
        lock (_gate)
        {
            subRefs = _bySid.Values.Select(m => m.WeakReference).ToArray();
            _bySid.Clear();
        }

        foreach (var subRef in subRefs)
        {
            if (subRef.TryGetTarget(out var sub))
                await sub.DisposeAsync().ConfigureAwait(false);
        }
    }

    public ValueTask RemoveAsync(NatsSubBase sub)
    {
        SubscriptionMetadata? subMetadata;
        lock (_gate)
        {
            if (!_bySub.TryGetValue(sub, out subMetadata))
            {
                // this can happen when a call to SubscribeAsync is canceled or timed out before subscribing
                // in that case, return as there is nothing to unsubscribe
                _logger.LogInformation(NatsLogEvents.Subscription, "No need to remove subscription {Subject}", sub.Subject);
                return default;
            }

            _bySub.Remove(sub);
            _bySid.TryRemove(subMetadata.Sid, out _);
        }

        if (_debug)
        {
            _logger.LogDebug(NatsLogEvents.Subscription, "Removing subscription {Subject}/{Sid}", sub.Subject, subMetadata.Sid);
        }

        return _connection.UnsubscribeAsync(sub.SubscriptionProps);
    }

    /// <summary>
    /// Returns commands for all the live subscriptions to be used on reconnect so that they can rebuild their connection state on the server.
    /// </summary>
    /// <remarks>
    /// Commands returned form all the subscriptions will be run as a priority right after reconnection is established.
    /// </remarks>
    /// <returns>Enumerable list of commands</returns>
    internal async ValueTask WriteReconnectCommandsAsync(CommandWriter commandWriter)
    {
        if (_debug)
        {
            _logger.LogDebug(NatsLogEvents.Subscription, "Reconnect commands requested");
        }

        var subs = new List<(NatsSubBase, int)>();
        lock (_gate)
        {
            foreach (var (sid, sidMetadata) in _bySid)
            {
                if (sidMetadata.WeakReference.TryGetTarget(out var sub))
                {
                    subs.Add((sub, sid));
                }
                else
                {
                    _logger.LogError(NatsLogEvents.Subscription, "While reconnecting found subscription GCd but was never disposed {SidMetadataSubject}/{Sid}", sidMetadata.Properties.Subject, sid);
                }
            }
        }

        foreach (var (sub, sid) in subs)
        {
            await sub.WriteReconnectCommandsAsync(commandWriter, new NatsSubscriptionProps(sid)).ConfigureAwait(false);

            if (_debug)
            {
                _logger.LogDebug(NatsLogEvents.Subscription, "Wrote reconnect commands for subscription {Subject}", sub.Subject);
            }
        }
    }

    internal INatsSubscriptionManager GetManagerFor(NatsSubscriptionProps props)
    {
        if (props.IsInboxSubject(_connection.InboxPrefix))
            return InboxSubBuilder;
        return this;
    }

    internal async Task InitializeInboxSubscriptionAsync(CancellationToken cancellationToken)
    {
        if (Interlocked.CompareExchange(ref _inboxSub, _inboxSubSentinel, _inboxSubSentinel) == _inboxSubSentinel)
        {
            await _inboxSubLock.WaitAsync(CancellationToken.None).ConfigureAwait(false);
            try
            {
                if (Interlocked.CompareExchange(ref _inboxSub, _inboxSubSentinel, _inboxSubSentinel) == _inboxSubSentinel)
                {
                    var inboxSubject = new NatsSubscriptionProps($"{_inboxPrefix}.*", _connection.InboxPrefix);

                    // We need to subscribe to the real inbox subject before we can register the internal subject.
                    // We use 'default' options here since options provided by the user are for the internal subscription.
                    // For example if the user provides a timeout, we don't want to timeout the real inbox subscription
                    // since it must live duration of the connection.
                    _inboxSub = InboxSubBuilder.Build(inboxSubject, opts: default, _connection, manager: this);
                    var props = new NatsSubscriptionProps(_inboxSub.Subject, _connection.InboxPrefix, _inboxSub.QueueGroup);
                    await SubscribeInternalAsync(
                        props,
                        _inboxSub,
                        cancellationToken).ConfigureAwait(false);
                }
            }
            finally
            {
                _inboxSubLock.Release();
            }
        }
    }

    private async ValueTask SubscribeInboxAsync(NatsSubBase sub, CancellationToken cancellationToken)
    {
        await InitializeInboxSubscriptionAsync(cancellationToken).ConfigureAwait(false);
        await InboxSubBuilder.RegisterAsync(sub).ConfigureAwait(false);
    }

    private async ValueTask SubscribeInternalAsync(NatsSubscriptionProps props, NatsSubBase sub, CancellationToken cancellationToken)
    {
        props.SubscriptionId = GetNextSid();

        if (sub is InboxSub)
        {
            Interlocked.Exchange(ref _inboxSid, props.SubscriptionId);
        }

        if (_debug)
        {
            _logger.LogDebug(NatsLogEvents.Subscription, "New subscription {Subject}/{Sid}", sub.Subject, props.SubscriptionId);
        }

        lock (_gate)
        {
            _bySid[props.SubscriptionId] = new SidMetadata(Properties: props, WeakReference: new WeakReference<NatsSubBase>(sub));
#if NETSTANDARD2_0
            lock (_bySub)
            {
                if (_bySub.TryGetValue(sub, out _))
                    _bySub.Remove(sub);
                _bySub.Add(sub, new SubscriptionMetadata(Sid: props.SubscriptionId));
            }
#else
            _bySub.AddOrUpdate(sub, new SubscriptionMetadata(Sid: props.SubscriptionId));
#endif
        }

        try
        {
            await _connection.SubscribeCoreAsync(props, sub.Opts?.MaxMsgs, cancellationToken).ConfigureAwait(false);
            await sub.ReadyAsync().ConfigureAwait(false);
        }
        catch
        {
            await sub.DisposeAsync().ConfigureAwait(false);
            throw;
        }
    }

    private int GetNextSid() => Interlocked.Increment(ref _sid);

    private async Task CleanupAsync()
    {
        while (!_cts.Token.IsCancellationRequested)
        {
            await Task.Delay(_cleanupInterval, _cts.Token).ConfigureAwait(false);

            // Avoid allocations most of the time
            List<int>? orphanSids = null;

            lock (_gate)
            {
                foreach (var (sid, sidMetadata) in _bySid)
                {
                    if (_cts.Token.IsCancellationRequested)
                        break;

                    if (sidMetadata.WeakReference.TryGetTarget(out _))
                        continue;

                    // NatsSub object GCed
                    _logger.LogWarning(NatsLogEvents.Subscription, "Subscription GCd but was never disposed {SidMetadataSubject}/{Sid}", sidMetadata.Properties.Subject, sid);
                    orphanSids ??= new List<int>();
                    orphanSids.Add(sid);
                }
            }

            if (orphanSids != null)
            {
                _logger.LogWarning(NatsLogEvents.Subscription, "Unsubscribing orphan subscriptions");
                await UnsubscribeSidsAsync(orphanSids).ConfigureAwait(false);
            }
        }
    }

    private async ValueTask UnsubscribeSidsAsync(List<int> sids)
    {
        foreach (var sid in sids)
        {
            try
            {
                _logger.LogWarning(NatsLogEvents.Subscription, "Unsubscribing orphan subscription {Sid}", sid);
                await _connection.UnsubscribeAsync(new NatsSubscriptionProps(sid)).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                _logger.LogWarning(NatsLogEvents.Subscription, "Error unsubscribing during cleanup: {Error}", e.GetBaseException().Message);
            }
        }
    }
}
